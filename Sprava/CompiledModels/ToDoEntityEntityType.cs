// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Hestia.Contract.Models;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Sprava.CompiledModels
{
    [EntityFrameworkInternal]
    public partial class ToDoEntityEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Hestia.Contract.Models.ToDoEntity",
                typeof(ToDoEntity),
                baseEntityType,
                propertyCount: 30,
                keyCount: 1);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(Guid),
                propertyInfo: typeof(ToDoEntity).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            id.SetGetter(
                Guid (ToDoEntity instance) => ToDoEntityUnsafeAccessors.Id(instance),
                bool (ToDoEntity instance) => ((object)ToDoEntityUnsafeAccessors.Id(instance)).Equals(((object)(new Guid("00000000-0000-0000-0000-000000000000")))));
            id.SetSetter(
                ToDoEntity (ToDoEntity instance, Guid value) =>
                {
                    ToDoEntityUnsafeAccessors.Id(instance) = value;
                    return instance;
                });
            id.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, Guid value) =>
                {
                    ToDoEntityUnsafeAccessors.Id(instance) = value;
                    return instance;
                });
            id.SetAccessors(
                Guid (IInternalEntry entry) => ToDoEntityUnsafeAccessors.Id(((ToDoEntity)(entry.Entity))),
                Guid (IInternalEntry entry) => ToDoEntityUnsafeAccessors.Id(((ToDoEntity)(entry.Entity))),
                Guid (IInternalEntry entry) => entry.ReadOriginalValue<Guid>(id, 0),
                Guid (IInternalEntry entry) => ((InternalEntityEntry)(entry)).ReadRelationshipSnapshotValue<Guid>(id, 0));
            id.SetPropertyIndexes(
                index: 0,
                originalValueIndex: 0,
                shadowIndex: -1,
                relationshipIndex: 0,
                storeGenerationIndex: -1);
            id.TypeMapping = SqliteGuidTypeMapping.Default;
            id.SetCurrentValueComparer(new EntryCurrentValueComparer<Guid>(id));
            id.SetComparer(new ValueComparer<Guid>(
                bool (Guid c1, Guid c2) => ((object)c1).Equals(((object)(c2))),
                int (Guid c) => ((object)c).GetHashCode(),
                Guid (Guid c) => c));

            var annuallyDays = runtimeEntityType.AddProperty(
                "AnnuallyDays",
                typeof(string),
                propertyInfo: typeof(ToDoEntity).GetProperty("AnnuallyDays", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<AnnuallyDays>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            annuallyDays.SetGetter(
                string (ToDoEntity instance) => ToDoEntityUnsafeAccessors.AnnuallyDays(instance),
                bool (ToDoEntity instance) => ToDoEntityUnsafeAccessors.AnnuallyDays(instance) == null);
            annuallyDays.SetSetter(
                ToDoEntity (ToDoEntity instance, string value) =>
                {
                    ToDoEntityUnsafeAccessors.AnnuallyDays(instance) = value;
                    return instance;
                });
            annuallyDays.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, string value) =>
                {
                    ToDoEntityUnsafeAccessors.AnnuallyDays(instance) = value;
                    return instance;
                });
            annuallyDays.SetAccessors(
                string (IInternalEntry entry) => ToDoEntityUnsafeAccessors.AnnuallyDays(((ToDoEntity)(entry.Entity))),
                string (IInternalEntry entry) => ToDoEntityUnsafeAccessors.AnnuallyDays(((ToDoEntity)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(annuallyDays, 1),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(annuallyDays));
            annuallyDays.SetPropertyIndexes(
                index: 1,
                originalValueIndex: 1,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            annuallyDays.TypeMapping = SqliteStringTypeMapping.Default;
            annuallyDays.SetComparer(new ValueComparer<string>(
                bool (string c1, string c2) => c1 == c2,
                int (string c) => ((object)c).GetHashCode(),
                string (string c) => c));

            var childrenCompletionType = runtimeEntityType.AddProperty(
                "ChildrenCompletionType",
                typeof(ChildrenCompletionType),
                propertyInfo: typeof(ToDoEntity).GetProperty("ChildrenCompletionType", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<ChildrenCompletionType>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            childrenCompletionType.SetGetter(
                ChildrenCompletionType (ToDoEntity instance) => ToDoEntityUnsafeAccessors.ChildrenCompletionType(instance),
                bool (ToDoEntity instance) => ((object)ToDoEntityUnsafeAccessors.ChildrenCompletionType(instance)).Equals(((object)(ChildrenCompletionType.RequireCompletion))));
            childrenCompletionType.SetSetter(
                ToDoEntity (ToDoEntity instance, ChildrenCompletionType value) =>
                {
                    ToDoEntityUnsafeAccessors.ChildrenCompletionType(instance) = value;
                    return instance;
                });
            childrenCompletionType.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, ChildrenCompletionType value) =>
                {
                    ToDoEntityUnsafeAccessors.ChildrenCompletionType(instance) = value;
                    return instance;
                });
            childrenCompletionType.SetAccessors(
                ChildrenCompletionType (IInternalEntry entry) => ToDoEntityUnsafeAccessors.ChildrenCompletionType(((ToDoEntity)(entry.Entity))),
                ChildrenCompletionType (IInternalEntry entry) => ToDoEntityUnsafeAccessors.ChildrenCompletionType(((ToDoEntity)(entry.Entity))),
                ChildrenCompletionType (IInternalEntry entry) => entry.ReadOriginalValue<ChildrenCompletionType>(childrenCompletionType, 2),
                ChildrenCompletionType (IInternalEntry entry) => entry.GetCurrentValue<ChildrenCompletionType>(childrenCompletionType));
            childrenCompletionType.SetPropertyIndexes(
                index: 2,
                originalValueIndex: 2,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            childrenCompletionType.TypeMapping = ByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<ChildrenCompletionType>(
                    bool (ChildrenCompletionType v1, ChildrenCompletionType v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (ChildrenCompletionType v) => ((object)v).GetHashCode(),
                    ChildrenCompletionType (ChildrenCompletionType v) => v),
                keyComparer: new ValueComparer<ChildrenCompletionType>(
                    bool (ChildrenCompletionType v1, ChildrenCompletionType v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (ChildrenCompletionType v) => ((object)v).GetHashCode(),
                    ChildrenCompletionType (ChildrenCompletionType v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<ChildrenCompletionType, byte>(
                    byte (ChildrenCompletionType value) => ((byte)(value)),
                    ChildrenCompletionType (byte value) => ((ChildrenCompletionType)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ChildrenCompletionType, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<ChildrenCompletionType, byte>(
                        byte (ChildrenCompletionType value) => ((byte)(value)),
                        ChildrenCompletionType (byte value) => ((ChildrenCompletionType)(value)))));
            childrenCompletionType.SetComparer(new ValueComparer<ChildrenCompletionType>(
                bool (ChildrenCompletionType c1, ChildrenCompletionType c2) => ((object)c1).Equals(((object)(c2))),
                int (ChildrenCompletionType c) => ((object)c).GetHashCode(),
                ChildrenCompletionType (ChildrenCompletionType c) => c));
            childrenCompletionType.SetSentinelFromProviderValue((byte)0);

            var color = runtimeEntityType.AddProperty(
                "Color",
                typeof(string),
                propertyInfo: typeof(ToDoEntity).GetProperty("Color", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<Color>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            color.SetGetter(
                string (ToDoEntity instance) => ToDoEntityUnsafeAccessors.Color(instance),
                bool (ToDoEntity instance) => ToDoEntityUnsafeAccessors.Color(instance) == null);
            color.SetSetter(
                ToDoEntity (ToDoEntity instance, string value) =>
                {
                    ToDoEntityUnsafeAccessors.Color(instance) = value;
                    return instance;
                });
            color.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, string value) =>
                {
                    ToDoEntityUnsafeAccessors.Color(instance) = value;
                    return instance;
                });
            color.SetAccessors(
                string (IInternalEntry entry) => ToDoEntityUnsafeAccessors.Color(((ToDoEntity)(entry.Entity))),
                string (IInternalEntry entry) => ToDoEntityUnsafeAccessors.Color(((ToDoEntity)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(color, 3),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(color));
            color.SetPropertyIndexes(
                index: 3,
                originalValueIndex: 3,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            color.TypeMapping = SqliteStringTypeMapping.Default;
            color.SetComparer(new ValueComparer<string>(
                bool (string c1, string c2) => c1 == c2,
                int (string c) => ((object)c).GetHashCode(),
                string (string c) => c));

            var createdDateTime = runtimeEntityType.AddProperty(
                "CreatedDateTime",
                typeof(DateTimeOffset),
                propertyInfo: typeof(ToDoEntity).GetProperty("CreatedDateTime", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<CreatedDateTime>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new DateTimeOffset(new DateTime(1, 1, 1, 0, 0, 0, 0, DateTimeKind.Unspecified), new TimeSpan(0, 0, 0, 0, 0)));
            createdDateTime.SetGetter(
                DateTimeOffset (ToDoEntity instance) => ToDoEntityUnsafeAccessors.CreatedDateTime(instance),
                bool (ToDoEntity instance) => ((object)ToDoEntityUnsafeAccessors.CreatedDateTime(instance)).Equals(((object)(default(DateTimeOffset)))));
            createdDateTime.SetSetter(
                ToDoEntity (ToDoEntity instance, DateTimeOffset value) =>
                {
                    ToDoEntityUnsafeAccessors.CreatedDateTime(instance) = value;
                    return instance;
                });
            createdDateTime.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, DateTimeOffset value) =>
                {
                    ToDoEntityUnsafeAccessors.CreatedDateTime(instance) = value;
                    return instance;
                });
            createdDateTime.SetAccessors(
                DateTimeOffset (IInternalEntry entry) => ToDoEntityUnsafeAccessors.CreatedDateTime(((ToDoEntity)(entry.Entity))),
                DateTimeOffset (IInternalEntry entry) => ToDoEntityUnsafeAccessors.CreatedDateTime(((ToDoEntity)(entry.Entity))),
                DateTimeOffset (IInternalEntry entry) => entry.ReadOriginalValue<DateTimeOffset>(createdDateTime, 4),
                DateTimeOffset (IInternalEntry entry) => entry.GetCurrentValue<DateTimeOffset>(createdDateTime));
            createdDateTime.SetPropertyIndexes(
                index: 4,
                originalValueIndex: 4,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            createdDateTime.TypeMapping = SqliteDateTimeOffsetTypeMapping.Default;
            createdDateTime.SetComparer(new ValueComparer<DateTimeOffset>(
                bool (DateTimeOffset c1, DateTimeOffset c2) => ((object)c1).Equals(((object)(c2))),
                int (DateTimeOffset c) => ((object)c).GetHashCode(),
                DateTimeOffset (DateTimeOffset c) => c));

            var currentCircleOrderIndex = runtimeEntityType.AddProperty(
                "CurrentCircleOrderIndex",
                typeof(uint),
                propertyInfo: typeof(ToDoEntity).GetProperty("CurrentCircleOrderIndex", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<CurrentCircleOrderIndex>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0u);
            currentCircleOrderIndex.SetGetter(
                uint (ToDoEntity instance) => ToDoEntityUnsafeAccessors.CurrentCircleOrderIndex(instance),
                bool (ToDoEntity instance) => ((object)ToDoEntityUnsafeAccessors.CurrentCircleOrderIndex(instance)).Equals(((object)(0U))));
            currentCircleOrderIndex.SetSetter(
                ToDoEntity (ToDoEntity instance, uint value) =>
                {
                    ToDoEntityUnsafeAccessors.CurrentCircleOrderIndex(instance) = value;
                    return instance;
                });
            currentCircleOrderIndex.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, uint value) =>
                {
                    ToDoEntityUnsafeAccessors.CurrentCircleOrderIndex(instance) = value;
                    return instance;
                });
            currentCircleOrderIndex.SetAccessors(
                uint (IInternalEntry entry) => ToDoEntityUnsafeAccessors.CurrentCircleOrderIndex(((ToDoEntity)(entry.Entity))),
                uint (IInternalEntry entry) => ToDoEntityUnsafeAccessors.CurrentCircleOrderIndex(((ToDoEntity)(entry.Entity))),
                uint (IInternalEntry entry) => entry.ReadOriginalValue<uint>(currentCircleOrderIndex, 5),
                uint (IInternalEntry entry) => entry.GetCurrentValue<uint>(currentCircleOrderIndex));
            currentCircleOrderIndex.SetPropertyIndexes(
                index: 5,
                originalValueIndex: 5,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            currentCircleOrderIndex.TypeMapping = UIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                keyComparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                providerValueComparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));
            currentCircleOrderIndex.SetComparer(new ValueComparer<uint>(
                bool (uint c1, uint c2) => ((object)c1).Equals(((object)(c2))),
                int (uint c) => ((object)c).GetHashCode(),
                uint (uint c) => c));

            var daysOffset = runtimeEntityType.AddProperty(
                "DaysOffset",
                typeof(ushort),
                propertyInfo: typeof(ToDoEntity).GetProperty("DaysOffset", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<DaysOffset>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (ushort)0);
            daysOffset.SetGetter(
                ushort (ToDoEntity instance) => ToDoEntityUnsafeAccessors.DaysOffset(instance),
                bool (ToDoEntity instance) => ((object)ToDoEntityUnsafeAccessors.DaysOffset(instance)).Equals(((object)(0))));
            daysOffset.SetSetter(
                ToDoEntity (ToDoEntity instance, ushort value) =>
                {
                    ToDoEntityUnsafeAccessors.DaysOffset(instance) = value;
                    return instance;
                });
            daysOffset.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, ushort value) =>
                {
                    ToDoEntityUnsafeAccessors.DaysOffset(instance) = value;
                    return instance;
                });
            daysOffset.SetAccessors(
                ushort (IInternalEntry entry) => ToDoEntityUnsafeAccessors.DaysOffset(((ToDoEntity)(entry.Entity))),
                ushort (IInternalEntry entry) => ToDoEntityUnsafeAccessors.DaysOffset(((ToDoEntity)(entry.Entity))),
                ushort (IInternalEntry entry) => entry.ReadOriginalValue<ushort>(daysOffset, 6),
                ushort (IInternalEntry entry) => entry.GetCurrentValue<ushort>(daysOffset));
            daysOffset.SetPropertyIndexes(
                index: 6,
                originalValueIndex: 6,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            daysOffset.TypeMapping = UShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v),
                keyComparer: new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v),
                providerValueComparer: new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));
            daysOffset.SetComparer(new ValueComparer<ushort>(
                bool (ushort c1, ushort c2) => ((object)c1).Equals(((object)(c2))),
                int (ushort c) => ((object)c).GetHashCode(),
                ushort (ushort c) => c));

            var description = runtimeEntityType.AddProperty(
                "Description",
                typeof(string),
                propertyInfo: typeof(ToDoEntity).GetProperty("Description", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<Description>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                maxLength: 10000);
            description.SetGetter(
                string (ToDoEntity instance) => ToDoEntityUnsafeAccessors.Description(instance),
                bool (ToDoEntity instance) => ToDoEntityUnsafeAccessors.Description(instance) == null);
            description.SetSetter(
                ToDoEntity (ToDoEntity instance, string value) =>
                {
                    ToDoEntityUnsafeAccessors.Description(instance) = value;
                    return instance;
                });
            description.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, string value) =>
                {
                    ToDoEntityUnsafeAccessors.Description(instance) = value;
                    return instance;
                });
            description.SetAccessors(
                string (IInternalEntry entry) => ToDoEntityUnsafeAccessors.Description(((ToDoEntity)(entry.Entity))),
                string (IInternalEntry entry) => ToDoEntityUnsafeAccessors.Description(((ToDoEntity)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(description, 7),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(description));
            description.SetPropertyIndexes(
                index: 7,
                originalValueIndex: 7,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            description.TypeMapping = SqliteStringTypeMapping.Default;
            description.SetComparer(new ValueComparer<string>(
                bool (string c1, string c2) => c1 == c2,
                int (string c) => ((object)c).GetHashCode(),
                string (string c) => c));

            var descriptionType = runtimeEntityType.AddProperty(
                "DescriptionType",
                typeof(DescriptionType),
                propertyInfo: typeof(ToDoEntity).GetProperty("DescriptionType", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<DescriptionType>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            descriptionType.SetGetter(
                DescriptionType (ToDoEntity instance) => ToDoEntityUnsafeAccessors.DescriptionType(instance),
                bool (ToDoEntity instance) => ((object)ToDoEntityUnsafeAccessors.DescriptionType(instance)).Equals(((object)(DescriptionType.PlainText))));
            descriptionType.SetSetter(
                ToDoEntity (ToDoEntity instance, DescriptionType value) =>
                {
                    ToDoEntityUnsafeAccessors.DescriptionType(instance) = value;
                    return instance;
                });
            descriptionType.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, DescriptionType value) =>
                {
                    ToDoEntityUnsafeAccessors.DescriptionType(instance) = value;
                    return instance;
                });
            descriptionType.SetAccessors(
                DescriptionType (IInternalEntry entry) => ToDoEntityUnsafeAccessors.DescriptionType(((ToDoEntity)(entry.Entity))),
                DescriptionType (IInternalEntry entry) => ToDoEntityUnsafeAccessors.DescriptionType(((ToDoEntity)(entry.Entity))),
                DescriptionType (IInternalEntry entry) => entry.ReadOriginalValue<DescriptionType>(descriptionType, 8),
                DescriptionType (IInternalEntry entry) => entry.GetCurrentValue<DescriptionType>(descriptionType));
            descriptionType.SetPropertyIndexes(
                index: 8,
                originalValueIndex: 8,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            descriptionType.TypeMapping = ByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<DescriptionType>(
                    bool (DescriptionType v1, DescriptionType v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (DescriptionType v) => ((object)v).GetHashCode(),
                    DescriptionType (DescriptionType v) => v),
                keyComparer: new ValueComparer<DescriptionType>(
                    bool (DescriptionType v1, DescriptionType v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (DescriptionType v) => ((object)v).GetHashCode(),
                    DescriptionType (DescriptionType v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<DescriptionType, byte>(
                    byte (DescriptionType value) => ((byte)(value)),
                    DescriptionType (byte value) => ((DescriptionType)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DescriptionType, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<DescriptionType, byte>(
                        byte (DescriptionType value) => ((byte)(value)),
                        DescriptionType (byte value) => ((DescriptionType)(value)))));
            descriptionType.SetComparer(new ValueComparer<DescriptionType>(
                bool (DescriptionType c1, DescriptionType c2) => ((object)c1).Equals(((object)(c2))),
                int (DescriptionType c) => ((object)c).GetHashCode(),
                DescriptionType (DescriptionType c) => c));
            descriptionType.SetSentinelFromProviderValue((byte)0);

            var dueDate = runtimeEntityType.AddProperty(
                "DueDate",
                typeof(DateOnly),
                propertyInfo: typeof(ToDoEntity).GetProperty("DueDate", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<DueDate>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: new DateOnly(1, 1, 1));
            dueDate.SetGetter(
                DateOnly (ToDoEntity instance) => ToDoEntityUnsafeAccessors.DueDate(instance),
                bool (ToDoEntity instance) => ((object)ToDoEntityUnsafeAccessors.DueDate(instance)).Equals(((object)(default(DateOnly)))));
            dueDate.SetSetter(
                ToDoEntity (ToDoEntity instance, DateOnly value) =>
                {
                    ToDoEntityUnsafeAccessors.DueDate(instance) = value;
                    return instance;
                });
            dueDate.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, DateOnly value) =>
                {
                    ToDoEntityUnsafeAccessors.DueDate(instance) = value;
                    return instance;
                });
            dueDate.SetAccessors(
                DateOnly (IInternalEntry entry) => ToDoEntityUnsafeAccessors.DueDate(((ToDoEntity)(entry.Entity))),
                DateOnly (IInternalEntry entry) => ToDoEntityUnsafeAccessors.DueDate(((ToDoEntity)(entry.Entity))),
                DateOnly (IInternalEntry entry) => entry.ReadOriginalValue<DateOnly>(dueDate, 9),
                DateOnly (IInternalEntry entry) => entry.GetCurrentValue<DateOnly>(dueDate));
            dueDate.SetPropertyIndexes(
                index: 9,
                originalValueIndex: 9,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            dueDate.TypeMapping = SqliteDateOnlyTypeMapping.Default;
            dueDate.SetComparer(new ValueComparer<DateOnly>(
                bool (DateOnly c1, DateOnly c2) => ((object)c1).Equals(((object)(c2))),
                int (DateOnly c) => ((object)c).GetHashCode(),
                DateOnly (DateOnly c) => c));

            var icon = runtimeEntityType.AddProperty(
                "Icon",
                typeof(string),
                propertyInfo: typeof(ToDoEntity).GetProperty("Icon", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<Icon>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            icon.SetGetter(
                string (ToDoEntity instance) => ToDoEntityUnsafeAccessors.Icon(instance),
                bool (ToDoEntity instance) => ToDoEntityUnsafeAccessors.Icon(instance) == null);
            icon.SetSetter(
                ToDoEntity (ToDoEntity instance, string value) =>
                {
                    ToDoEntityUnsafeAccessors.Icon(instance) = value;
                    return instance;
                });
            icon.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, string value) =>
                {
                    ToDoEntityUnsafeAccessors.Icon(instance) = value;
                    return instance;
                });
            icon.SetAccessors(
                string (IInternalEntry entry) => ToDoEntityUnsafeAccessors.Icon(((ToDoEntity)(entry.Entity))),
                string (IInternalEntry entry) => ToDoEntityUnsafeAccessors.Icon(((ToDoEntity)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(icon, 10),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(icon));
            icon.SetPropertyIndexes(
                index: 10,
                originalValueIndex: 10,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            icon.TypeMapping = SqliteStringTypeMapping.Default;
            icon.SetComparer(new ValueComparer<string>(
                bool (string c1, string c2) => c1 == c2,
                int (string c) => ((object)c).GetHashCode(),
                string (string c) => c));

            var isBookmark = runtimeEntityType.AddProperty(
                "IsBookmark",
                typeof(bool),
                propertyInfo: typeof(ToDoEntity).GetProperty("IsBookmark", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<IsBookmark>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            isBookmark.SetGetter(
                bool (ToDoEntity instance) => ToDoEntityUnsafeAccessors.IsBookmark(instance),
                bool (ToDoEntity instance) => ((object)ToDoEntityUnsafeAccessors.IsBookmark(instance)).Equals(((object)(false))));
            isBookmark.SetSetter(
                ToDoEntity (ToDoEntity instance, bool value) =>
                {
                    ToDoEntityUnsafeAccessors.IsBookmark(instance) = value;
                    return instance;
                });
            isBookmark.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, bool value) =>
                {
                    ToDoEntityUnsafeAccessors.IsBookmark(instance) = value;
                    return instance;
                });
            isBookmark.SetAccessors(
                bool (IInternalEntry entry) => ToDoEntityUnsafeAccessors.IsBookmark(((ToDoEntity)(entry.Entity))),
                bool (IInternalEntry entry) => ToDoEntityUnsafeAccessors.IsBookmark(((ToDoEntity)(entry.Entity))),
                bool (IInternalEntry entry) => entry.ReadOriginalValue<bool>(isBookmark, 11),
                bool (IInternalEntry entry) => entry.GetCurrentValue<bool>(isBookmark));
            isBookmark.SetPropertyIndexes(
                index: 11,
                originalValueIndex: 11,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            isBookmark.TypeMapping = BoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));
            isBookmark.SetComparer(new ValueComparer<bool>(
                bool (bool c1, bool c2) => ((object)c1).Equals(((object)(c2))),
                int (bool c) => ((object)c).GetHashCode(),
                bool (bool c) => c));

            var isCompleted = runtimeEntityType.AddProperty(
                "IsCompleted",
                typeof(bool),
                propertyInfo: typeof(ToDoEntity).GetProperty("IsCompleted", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<IsCompleted>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            isCompleted.SetGetter(
                bool (ToDoEntity instance) => ToDoEntityUnsafeAccessors.IsCompleted(instance),
                bool (ToDoEntity instance) => ((object)ToDoEntityUnsafeAccessors.IsCompleted(instance)).Equals(((object)(false))));
            isCompleted.SetSetter(
                ToDoEntity (ToDoEntity instance, bool value) =>
                {
                    ToDoEntityUnsafeAccessors.IsCompleted(instance) = value;
                    return instance;
                });
            isCompleted.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, bool value) =>
                {
                    ToDoEntityUnsafeAccessors.IsCompleted(instance) = value;
                    return instance;
                });
            isCompleted.SetAccessors(
                bool (IInternalEntry entry) => ToDoEntityUnsafeAccessors.IsCompleted(((ToDoEntity)(entry.Entity))),
                bool (IInternalEntry entry) => ToDoEntityUnsafeAccessors.IsCompleted(((ToDoEntity)(entry.Entity))),
                bool (IInternalEntry entry) => entry.ReadOriginalValue<bool>(isCompleted, 12),
                bool (IInternalEntry entry) => entry.GetCurrentValue<bool>(isCompleted));
            isCompleted.SetPropertyIndexes(
                index: 12,
                originalValueIndex: 12,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            isCompleted.TypeMapping = BoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));
            isCompleted.SetComparer(new ValueComparer<bool>(
                bool (bool c1, bool c2) => ((object)c1).Equals(((object)(c2))),
                int (bool c) => ((object)c).GetHashCode(),
                bool (bool c) => c));

            var isFavorite = runtimeEntityType.AddProperty(
                "IsFavorite",
                typeof(bool),
                propertyInfo: typeof(ToDoEntity).GetProperty("IsFavorite", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<IsFavorite>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            isFavorite.SetGetter(
                bool (ToDoEntity instance) => ToDoEntityUnsafeAccessors.IsFavorite(instance),
                bool (ToDoEntity instance) => ((object)ToDoEntityUnsafeAccessors.IsFavorite(instance)).Equals(((object)(false))));
            isFavorite.SetSetter(
                ToDoEntity (ToDoEntity instance, bool value) =>
                {
                    ToDoEntityUnsafeAccessors.IsFavorite(instance) = value;
                    return instance;
                });
            isFavorite.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, bool value) =>
                {
                    ToDoEntityUnsafeAccessors.IsFavorite(instance) = value;
                    return instance;
                });
            isFavorite.SetAccessors(
                bool (IInternalEntry entry) => ToDoEntityUnsafeAccessors.IsFavorite(((ToDoEntity)(entry.Entity))),
                bool (IInternalEntry entry) => ToDoEntityUnsafeAccessors.IsFavorite(((ToDoEntity)(entry.Entity))),
                bool (IInternalEntry entry) => entry.ReadOriginalValue<bool>(isFavorite, 13),
                bool (IInternalEntry entry) => entry.GetCurrentValue<bool>(isFavorite));
            isFavorite.SetPropertyIndexes(
                index: 13,
                originalValueIndex: 13,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            isFavorite.TypeMapping = BoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));
            isFavorite.SetComparer(new ValueComparer<bool>(
                bool (bool c1, bool c2) => ((object)c1).Equals(((object)(c2))),
                int (bool c) => ((object)c).GetHashCode(),
                bool (bool c) => c));

            var isRequiredCompleteInDueDate = runtimeEntityType.AddProperty(
                "IsRequiredCompleteInDueDate",
                typeof(bool),
                propertyInfo: typeof(ToDoEntity).GetProperty("IsRequiredCompleteInDueDate", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<IsRequiredCompleteInDueDate>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            isRequiredCompleteInDueDate.SetGetter(
                bool (ToDoEntity instance) => ToDoEntityUnsafeAccessors.IsRequiredCompleteInDueDate(instance),
                bool (ToDoEntity instance) => ((object)ToDoEntityUnsafeAccessors.IsRequiredCompleteInDueDate(instance)).Equals(((object)(false))));
            isRequiredCompleteInDueDate.SetSetter(
                ToDoEntity (ToDoEntity instance, bool value) =>
                {
                    ToDoEntityUnsafeAccessors.IsRequiredCompleteInDueDate(instance) = value;
                    return instance;
                });
            isRequiredCompleteInDueDate.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, bool value) =>
                {
                    ToDoEntityUnsafeAccessors.IsRequiredCompleteInDueDate(instance) = value;
                    return instance;
                });
            isRequiredCompleteInDueDate.SetAccessors(
                bool (IInternalEntry entry) => ToDoEntityUnsafeAccessors.IsRequiredCompleteInDueDate(((ToDoEntity)(entry.Entity))),
                bool (IInternalEntry entry) => ToDoEntityUnsafeAccessors.IsRequiredCompleteInDueDate(((ToDoEntity)(entry.Entity))),
                bool (IInternalEntry entry) => entry.ReadOriginalValue<bool>(isRequiredCompleteInDueDate, 14),
                bool (IInternalEntry entry) => entry.GetCurrentValue<bool>(isRequiredCompleteInDueDate));
            isRequiredCompleteInDueDate.SetPropertyIndexes(
                index: 14,
                originalValueIndex: 14,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            isRequiredCompleteInDueDate.TypeMapping = BoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));
            isRequiredCompleteInDueDate.SetComparer(new ValueComparer<bool>(
                bool (bool c1, bool c2) => ((object)c1).Equals(((object)(c2))),
                int (bool c) => ((object)c).GetHashCode(),
                bool (bool c) => c));

            var lastCompleted = runtimeEntityType.AddProperty(
                "LastCompleted",
                typeof(DateTimeOffset?),
                propertyInfo: typeof(ToDoEntity).GetProperty("LastCompleted", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<LastCompleted>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            lastCompleted.SetGetter(
                DateTimeOffset? (ToDoEntity instance) => ToDoEntityUnsafeAccessors.LastCompleted(instance),
                bool (ToDoEntity instance) => !(ToDoEntityUnsafeAccessors.LastCompleted(instance).HasValue));
            lastCompleted.SetSetter(
                ToDoEntity (ToDoEntity instance, DateTimeOffset? value) =>
                {
                    ToDoEntityUnsafeAccessors.LastCompleted(instance) = value;
                    return instance;
                });
            lastCompleted.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, DateTimeOffset? value) =>
                {
                    ToDoEntityUnsafeAccessors.LastCompleted(instance) = value;
                    return instance;
                });
            lastCompleted.SetAccessors(
                DateTimeOffset? (IInternalEntry entry) => ToDoEntityUnsafeAccessors.LastCompleted(((ToDoEntity)(entry.Entity))),
                DateTimeOffset? (IInternalEntry entry) => ToDoEntityUnsafeAccessors.LastCompleted(((ToDoEntity)(entry.Entity))),
                DateTimeOffset? (IInternalEntry entry) => entry.ReadOriginalValue<DateTimeOffset?>(lastCompleted, 15),
                DateTimeOffset? (IInternalEntry entry) => entry.GetCurrentValue<DateTimeOffset?>(lastCompleted));
            lastCompleted.SetPropertyIndexes(
                index: 15,
                originalValueIndex: 15,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            lastCompleted.TypeMapping = SqliteDateTimeOffsetTypeMapping.Default;
            lastCompleted.SetComparer(new ValueComparer<DateTimeOffset?>(
                bool (DateTimeOffset? c1, DateTimeOffset? c2) => c1.HasValue || c2.HasValue && c1.HasValue && c2.HasValue && ((object)c1.Value).Equals(((object)(c2.Value))),
                int (DateTimeOffset? c) => (c == null ? 0 : ((object)c).GetHashCode()),
                DateTimeOffset? (DateTimeOffset? c) => c));

            var link = runtimeEntityType.AddProperty(
                "Link",
                typeof(string),
                propertyInfo: typeof(ToDoEntity).GetProperty("Link", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<Link>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                maxLength: 1000);
            link.SetGetter(
                string (ToDoEntity instance) => ToDoEntityUnsafeAccessors.Link(instance),
                bool (ToDoEntity instance) => ToDoEntityUnsafeAccessors.Link(instance) == null);
            link.SetSetter(
                ToDoEntity (ToDoEntity instance, string value) =>
                {
                    ToDoEntityUnsafeAccessors.Link(instance) = value;
                    return instance;
                });
            link.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, string value) =>
                {
                    ToDoEntityUnsafeAccessors.Link(instance) = value;
                    return instance;
                });
            link.SetAccessors(
                string (IInternalEntry entry) => ToDoEntityUnsafeAccessors.Link(((ToDoEntity)(entry.Entity))),
                string (IInternalEntry entry) => ToDoEntityUnsafeAccessors.Link(((ToDoEntity)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(link, 16),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(link));
            link.SetPropertyIndexes(
                index: 16,
                originalValueIndex: 16,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            link.TypeMapping = SqliteStringTypeMapping.Default;
            link.SetComparer(new ValueComparer<string>(
                bool (string c1, string c2) => c1 == c2,
                int (string c) => ((object)c).GetHashCode(),
                string (string c) => c));

            var monthlyDays = runtimeEntityType.AddProperty(
                "MonthlyDays",
                typeof(string),
                propertyInfo: typeof(ToDoEntity).GetProperty("MonthlyDays", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<MonthlyDays>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            monthlyDays.SetGetter(
                string (ToDoEntity instance) => ToDoEntityUnsafeAccessors.MonthlyDays(instance),
                bool (ToDoEntity instance) => ToDoEntityUnsafeAccessors.MonthlyDays(instance) == null);
            monthlyDays.SetSetter(
                ToDoEntity (ToDoEntity instance, string value) =>
                {
                    ToDoEntityUnsafeAccessors.MonthlyDays(instance) = value;
                    return instance;
                });
            monthlyDays.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, string value) =>
                {
                    ToDoEntityUnsafeAccessors.MonthlyDays(instance) = value;
                    return instance;
                });
            monthlyDays.SetAccessors(
                string (IInternalEntry entry) => ToDoEntityUnsafeAccessors.MonthlyDays(((ToDoEntity)(entry.Entity))),
                string (IInternalEntry entry) => ToDoEntityUnsafeAccessors.MonthlyDays(((ToDoEntity)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(monthlyDays, 17),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(monthlyDays));
            monthlyDays.SetPropertyIndexes(
                index: 17,
                originalValueIndex: 17,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            monthlyDays.TypeMapping = SqliteStringTypeMapping.Default;
            monthlyDays.SetComparer(new ValueComparer<string>(
                bool (string c1, string c2) => c1 == c2,
                int (string c) => ((object)c).GetHashCode(),
                string (string c) => c));

            var monthsOffset = runtimeEntityType.AddProperty(
                "MonthsOffset",
                typeof(ushort),
                propertyInfo: typeof(ToDoEntity).GetProperty("MonthsOffset", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<MonthsOffset>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (ushort)0);
            monthsOffset.SetGetter(
                ushort (ToDoEntity instance) => ToDoEntityUnsafeAccessors.MonthsOffset(instance),
                bool (ToDoEntity instance) => ((object)ToDoEntityUnsafeAccessors.MonthsOffset(instance)).Equals(((object)(0))));
            monthsOffset.SetSetter(
                ToDoEntity (ToDoEntity instance, ushort value) =>
                {
                    ToDoEntityUnsafeAccessors.MonthsOffset(instance) = value;
                    return instance;
                });
            monthsOffset.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, ushort value) =>
                {
                    ToDoEntityUnsafeAccessors.MonthsOffset(instance) = value;
                    return instance;
                });
            monthsOffset.SetAccessors(
                ushort (IInternalEntry entry) => ToDoEntityUnsafeAccessors.MonthsOffset(((ToDoEntity)(entry.Entity))),
                ushort (IInternalEntry entry) => ToDoEntityUnsafeAccessors.MonthsOffset(((ToDoEntity)(entry.Entity))),
                ushort (IInternalEntry entry) => entry.ReadOriginalValue<ushort>(monthsOffset, 18),
                ushort (IInternalEntry entry) => entry.GetCurrentValue<ushort>(monthsOffset));
            monthsOffset.SetPropertyIndexes(
                index: 18,
                originalValueIndex: 18,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            monthsOffset.TypeMapping = UShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v),
                keyComparer: new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v),
                providerValueComparer: new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));
            monthsOffset.SetComparer(new ValueComparer<ushort>(
                bool (ushort c1, ushort c2) => ((object)c1).Equals(((object)(c2))),
                int (ushort c) => ((object)c).GetHashCode(),
                ushort (ushort c) => c));

            var name = runtimeEntityType.AddProperty(
                "Name",
                typeof(string),
                propertyInfo: typeof(ToDoEntity).GetProperty("Name", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<Name>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                maxLength: 255);
            name.SetGetter(
                string (ToDoEntity instance) => ToDoEntityUnsafeAccessors.Name(instance),
                bool (ToDoEntity instance) => ToDoEntityUnsafeAccessors.Name(instance) == null);
            name.SetSetter(
                ToDoEntity (ToDoEntity instance, string value) =>
                {
                    ToDoEntityUnsafeAccessors.Name(instance) = value;
                    return instance;
                });
            name.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, string value) =>
                {
                    ToDoEntityUnsafeAccessors.Name(instance) = value;
                    return instance;
                });
            name.SetAccessors(
                string (IInternalEntry entry) => ToDoEntityUnsafeAccessors.Name(((ToDoEntity)(entry.Entity))),
                string (IInternalEntry entry) => ToDoEntityUnsafeAccessors.Name(((ToDoEntity)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(name, 19),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(name));
            name.SetPropertyIndexes(
                index: 19,
                originalValueIndex: 19,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            name.TypeMapping = SqliteStringTypeMapping.Default;
            name.SetComparer(new ValueComparer<string>(
                bool (string c1, string c2) => c1 == c2,
                int (string c) => ((object)c).GetHashCode(),
                string (string c) => c));

            var normalizeName = runtimeEntityType.AddProperty(
                "NormalizeName",
                typeof(string),
                propertyInfo: typeof(ToDoEntity).GetProperty("NormalizeName", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<NormalizeName>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                maxLength: 255);
            normalizeName.SetGetter(
                string (ToDoEntity instance) => ToDoEntityUnsafeAccessors.NormalizeName(instance),
                bool (ToDoEntity instance) => ToDoEntityUnsafeAccessors.NormalizeName(instance) == null);
            normalizeName.SetSetter(
                ToDoEntity (ToDoEntity instance, string value) =>
                {
                    ToDoEntityUnsafeAccessors.NormalizeName(instance) = value;
                    return instance;
                });
            normalizeName.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, string value) =>
                {
                    ToDoEntityUnsafeAccessors.NormalizeName(instance) = value;
                    return instance;
                });
            normalizeName.SetAccessors(
                string (IInternalEntry entry) => ToDoEntityUnsafeAccessors.NormalizeName(((ToDoEntity)(entry.Entity))),
                string (IInternalEntry entry) => ToDoEntityUnsafeAccessors.NormalizeName(((ToDoEntity)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(normalizeName, 20),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(normalizeName));
            normalizeName.SetPropertyIndexes(
                index: 20,
                originalValueIndex: 20,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            normalizeName.TypeMapping = SqliteStringTypeMapping.Default;
            normalizeName.SetComparer(new ValueComparer<string>(
                bool (string c1, string c2) => c1 == c2,
                int (string c) => ((object)c).GetHashCode(),
                string (string c) => c));

            var orderIndex = runtimeEntityType.AddProperty(
                "OrderIndex",
                typeof(uint),
                propertyInfo: typeof(ToDoEntity).GetProperty("OrderIndex", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<OrderIndex>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0u);
            orderIndex.SetGetter(
                uint (ToDoEntity instance) => ToDoEntityUnsafeAccessors.OrderIndex(instance),
                bool (ToDoEntity instance) => ((object)ToDoEntityUnsafeAccessors.OrderIndex(instance)).Equals(((object)(0U))));
            orderIndex.SetSetter(
                ToDoEntity (ToDoEntity instance, uint value) =>
                {
                    ToDoEntityUnsafeAccessors.OrderIndex(instance) = value;
                    return instance;
                });
            orderIndex.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, uint value) =>
                {
                    ToDoEntityUnsafeAccessors.OrderIndex(instance) = value;
                    return instance;
                });
            orderIndex.SetAccessors(
                uint (IInternalEntry entry) => ToDoEntityUnsafeAccessors.OrderIndex(((ToDoEntity)(entry.Entity))),
                uint (IInternalEntry entry) => ToDoEntityUnsafeAccessors.OrderIndex(((ToDoEntity)(entry.Entity))),
                uint (IInternalEntry entry) => entry.ReadOriginalValue<uint>(orderIndex, 21),
                uint (IInternalEntry entry) => entry.GetCurrentValue<uint>(orderIndex));
            orderIndex.SetPropertyIndexes(
                index: 21,
                originalValueIndex: 21,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            orderIndex.TypeMapping = UIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                keyComparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                providerValueComparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));
            orderIndex.SetComparer(new ValueComparer<uint>(
                bool (uint c1, uint c2) => ((object)c1).Equals(((object)(c2))),
                int (uint c) => ((object)c).GetHashCode(),
                uint (uint c) => c));

            var parentId = runtimeEntityType.AddProperty(
                "ParentId",
                typeof(Guid?),
                propertyInfo: typeof(ToDoEntity).GetProperty("ParentId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<ParentId>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            parentId.SetGetter(
                Guid? (ToDoEntity instance) => ToDoEntityUnsafeAccessors.ParentId(instance),
                bool (ToDoEntity instance) => !(ToDoEntityUnsafeAccessors.ParentId(instance).HasValue));
            parentId.SetSetter(
                ToDoEntity (ToDoEntity instance, Guid? value) =>
                {
                    ToDoEntityUnsafeAccessors.ParentId(instance) = value;
                    return instance;
                });
            parentId.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, Guid? value) =>
                {
                    ToDoEntityUnsafeAccessors.ParentId(instance) = value;
                    return instance;
                });
            parentId.SetAccessors(
                Guid? (IInternalEntry entry) => ToDoEntityUnsafeAccessors.ParentId(((ToDoEntity)(entry.Entity))),
                Guid? (IInternalEntry entry) => ToDoEntityUnsafeAccessors.ParentId(((ToDoEntity)(entry.Entity))),
                Guid? (IInternalEntry entry) => entry.ReadOriginalValue<Guid?>(parentId, 22),
                Guid? (IInternalEntry entry) => entry.GetCurrentValue<Guid?>(parentId));
            parentId.SetPropertyIndexes(
                index: 22,
                originalValueIndex: 22,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            parentId.TypeMapping = SqliteGuidTypeMapping.Default;
            parentId.SetComparer(new ValueComparer<Guid?>(
                bool (Guid? c1, Guid? c2) => c1.HasValue || c2.HasValue && c1.HasValue && c2.HasValue && ((object)c1.Value).Equals(((object)(c2.Value))),
                int (Guid? c) => (c == null ? 0 : ((object)c).GetHashCode()),
                Guid? (Guid? c) => c));

            var referenceId = runtimeEntityType.AddProperty(
                "ReferenceId",
                typeof(Guid?),
                propertyInfo: typeof(ToDoEntity).GetProperty("ReferenceId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<ReferenceId>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            referenceId.SetGetter(
                Guid? (ToDoEntity instance) => ToDoEntityUnsafeAccessors.ReferenceId(instance),
                bool (ToDoEntity instance) => !(ToDoEntityUnsafeAccessors.ReferenceId(instance).HasValue));
            referenceId.SetSetter(
                ToDoEntity (ToDoEntity instance, Guid? value) =>
                {
                    ToDoEntityUnsafeAccessors.ReferenceId(instance) = value;
                    return instance;
                });
            referenceId.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, Guid? value) =>
                {
                    ToDoEntityUnsafeAccessors.ReferenceId(instance) = value;
                    return instance;
                });
            referenceId.SetAccessors(
                Guid? (IInternalEntry entry) => ToDoEntityUnsafeAccessors.ReferenceId(((ToDoEntity)(entry.Entity))),
                Guid? (IInternalEntry entry) => ToDoEntityUnsafeAccessors.ReferenceId(((ToDoEntity)(entry.Entity))),
                Guid? (IInternalEntry entry) => entry.ReadOriginalValue<Guid?>(referenceId, 23),
                Guid? (IInternalEntry entry) => entry.GetCurrentValue<Guid?>(referenceId));
            referenceId.SetPropertyIndexes(
                index: 23,
                originalValueIndex: 23,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            referenceId.TypeMapping = SqliteGuidTypeMapping.Default;
            referenceId.SetComparer(new ValueComparer<Guid?>(
                bool (Guid? c1, Guid? c2) => c1.HasValue || c2.HasValue && c1.HasValue && c2.HasValue && ((object)c1.Value).Equals(((object)(c2.Value))),
                int (Guid? c) => (c == null ? 0 : ((object)c).GetHashCode()),
                Guid? (Guid? c) => c));

            var remindDaysBefore = runtimeEntityType.AddProperty(
                "RemindDaysBefore",
                typeof(uint),
                propertyInfo: typeof(ToDoEntity).GetProperty("RemindDaysBefore", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<RemindDaysBefore>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0u);
            remindDaysBefore.SetGetter(
                uint (ToDoEntity instance) => ToDoEntityUnsafeAccessors.RemindDaysBefore(instance),
                bool (ToDoEntity instance) => ((object)ToDoEntityUnsafeAccessors.RemindDaysBefore(instance)).Equals(((object)(0U))));
            remindDaysBefore.SetSetter(
                ToDoEntity (ToDoEntity instance, uint value) =>
                {
                    ToDoEntityUnsafeAccessors.RemindDaysBefore(instance) = value;
                    return instance;
                });
            remindDaysBefore.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, uint value) =>
                {
                    ToDoEntityUnsafeAccessors.RemindDaysBefore(instance) = value;
                    return instance;
                });
            remindDaysBefore.SetAccessors(
                uint (IInternalEntry entry) => ToDoEntityUnsafeAccessors.RemindDaysBefore(((ToDoEntity)(entry.Entity))),
                uint (IInternalEntry entry) => ToDoEntityUnsafeAccessors.RemindDaysBefore(((ToDoEntity)(entry.Entity))),
                uint (IInternalEntry entry) => entry.ReadOriginalValue<uint>(remindDaysBefore, 24),
                uint (IInternalEntry entry) => entry.GetCurrentValue<uint>(remindDaysBefore));
            remindDaysBefore.SetPropertyIndexes(
                index: 24,
                originalValueIndex: 24,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            remindDaysBefore.TypeMapping = UIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                keyComparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                providerValueComparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));
            remindDaysBefore.SetComparer(new ValueComparer<uint>(
                bool (uint c1, uint c2) => ((object)c1).Equals(((object)(c2))),
                int (uint c) => ((object)c).GetHashCode(),
                uint (uint c) => c));

            var type = runtimeEntityType.AddProperty(
                "Type",
                typeof(ToDoType),
                propertyInfo: typeof(ToDoEntity).GetProperty("Type", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<Type>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            type.SetGetter(
                ToDoType (ToDoEntity instance) => ToDoEntityUnsafeAccessors.Type(instance),
                bool (ToDoEntity instance) => ((object)ToDoEntityUnsafeAccessors.Type(instance)).Equals(((object)(ToDoType.Value))));
            type.SetSetter(
                ToDoEntity (ToDoEntity instance, ToDoType value) =>
                {
                    ToDoEntityUnsafeAccessors.Type(instance) = value;
                    return instance;
                });
            type.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, ToDoType value) =>
                {
                    ToDoEntityUnsafeAccessors.Type(instance) = value;
                    return instance;
                });
            type.SetAccessors(
                ToDoType (IInternalEntry entry) => ToDoEntityUnsafeAccessors.Type(((ToDoEntity)(entry.Entity))),
                ToDoType (IInternalEntry entry) => ToDoEntityUnsafeAccessors.Type(((ToDoEntity)(entry.Entity))),
                ToDoType (IInternalEntry entry) => entry.ReadOriginalValue<ToDoType>(type, 25),
                ToDoType (IInternalEntry entry) => entry.GetCurrentValue<ToDoType>(type));
            type.SetPropertyIndexes(
                index: 25,
                originalValueIndex: 25,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            type.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<ToDoType>(
                    bool (ToDoType v1, ToDoType v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (ToDoType v) => ((object)v).GetHashCode(),
                    ToDoType (ToDoType v) => v),
                keyComparer: new ValueComparer<ToDoType>(
                    bool (ToDoType v1, ToDoType v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (ToDoType v) => ((object)v).GetHashCode(),
                    ToDoType (ToDoType v) => v),
                providerValueComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<ToDoType, int>(
                    int (ToDoType value) => ((int)(value)),
                    ToDoType (int value) => ((ToDoType)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<ToDoType, int>(
                    JsonInt32ReaderWriter.Instance,
                    new ValueConverter<ToDoType, int>(
                        int (ToDoType value) => ((int)(value)),
                        ToDoType (int value) => ((ToDoType)(value)))));
            type.SetComparer(new ValueComparer<ToDoType>(
                bool (ToDoType c1, ToDoType c2) => ((object)c1).Equals(((object)(c2))),
                int (ToDoType c) => ((object)c).GetHashCode(),
                ToDoType (ToDoType c) => c));
            type.SetSentinelFromProviderValue(0);

            var typeOfPeriodicity = runtimeEntityType.AddProperty(
                "TypeOfPeriodicity",
                typeof(TypeOfPeriodicity),
                propertyInfo: typeof(ToDoEntity).GetProperty("TypeOfPeriodicity", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<TypeOfPeriodicity>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            typeOfPeriodicity.SetGetter(
                TypeOfPeriodicity (ToDoEntity instance) => ToDoEntityUnsafeAccessors.TypeOfPeriodicity(instance),
                bool (ToDoEntity instance) => ((object)ToDoEntityUnsafeAccessors.TypeOfPeriodicity(instance)).Equals(((object)(TypeOfPeriodicity.Daily))));
            typeOfPeriodicity.SetSetter(
                ToDoEntity (ToDoEntity instance, TypeOfPeriodicity value) =>
                {
                    ToDoEntityUnsafeAccessors.TypeOfPeriodicity(instance) = value;
                    return instance;
                });
            typeOfPeriodicity.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, TypeOfPeriodicity value) =>
                {
                    ToDoEntityUnsafeAccessors.TypeOfPeriodicity(instance) = value;
                    return instance;
                });
            typeOfPeriodicity.SetAccessors(
                TypeOfPeriodicity (IInternalEntry entry) => ToDoEntityUnsafeAccessors.TypeOfPeriodicity(((ToDoEntity)(entry.Entity))),
                TypeOfPeriodicity (IInternalEntry entry) => ToDoEntityUnsafeAccessors.TypeOfPeriodicity(((ToDoEntity)(entry.Entity))),
                TypeOfPeriodicity (IInternalEntry entry) => entry.ReadOriginalValue<TypeOfPeriodicity>(typeOfPeriodicity, 26),
                TypeOfPeriodicity (IInternalEntry entry) => entry.GetCurrentValue<TypeOfPeriodicity>(typeOfPeriodicity));
            typeOfPeriodicity.SetPropertyIndexes(
                index: 26,
                originalValueIndex: 26,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            typeOfPeriodicity.TypeMapping = ByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<TypeOfPeriodicity>(
                    bool (TypeOfPeriodicity v1, TypeOfPeriodicity v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (TypeOfPeriodicity v) => ((object)v).GetHashCode(),
                    TypeOfPeriodicity (TypeOfPeriodicity v) => v),
                keyComparer: new ValueComparer<TypeOfPeriodicity>(
                    bool (TypeOfPeriodicity v1, TypeOfPeriodicity v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (TypeOfPeriodicity v) => ((object)v).GetHashCode(),
                    TypeOfPeriodicity (TypeOfPeriodicity v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<TypeOfPeriodicity, byte>(
                    byte (TypeOfPeriodicity value) => ((byte)(value)),
                    TypeOfPeriodicity (byte value) => ((TypeOfPeriodicity)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<TypeOfPeriodicity, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<TypeOfPeriodicity, byte>(
                        byte (TypeOfPeriodicity value) => ((byte)(value)),
                        TypeOfPeriodicity (byte value) => ((TypeOfPeriodicity)(value)))));
            typeOfPeriodicity.SetComparer(new ValueComparer<TypeOfPeriodicity>(
                bool (TypeOfPeriodicity c1, TypeOfPeriodicity c2) => ((object)c1).Equals(((object)(c2))),
                int (TypeOfPeriodicity c) => ((object)c).GetHashCode(),
                TypeOfPeriodicity (TypeOfPeriodicity c) => c));
            typeOfPeriodicity.SetSentinelFromProviderValue((byte)0);

            var weeklyDays = runtimeEntityType.AddProperty(
                "WeeklyDays",
                typeof(string),
                propertyInfo: typeof(ToDoEntity).GetProperty("WeeklyDays", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<WeeklyDays>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            weeklyDays.SetGetter(
                string (ToDoEntity instance) => ToDoEntityUnsafeAccessors.WeeklyDays(instance),
                bool (ToDoEntity instance) => ToDoEntityUnsafeAccessors.WeeklyDays(instance) == null);
            weeklyDays.SetSetter(
                ToDoEntity (ToDoEntity instance, string value) =>
                {
                    ToDoEntityUnsafeAccessors.WeeklyDays(instance) = value;
                    return instance;
                });
            weeklyDays.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, string value) =>
                {
                    ToDoEntityUnsafeAccessors.WeeklyDays(instance) = value;
                    return instance;
                });
            weeklyDays.SetAccessors(
                string (IInternalEntry entry) => ToDoEntityUnsafeAccessors.WeeklyDays(((ToDoEntity)(entry.Entity))),
                string (IInternalEntry entry) => ToDoEntityUnsafeAccessors.WeeklyDays(((ToDoEntity)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(weeklyDays, 27),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(weeklyDays));
            weeklyDays.SetPropertyIndexes(
                index: 27,
                originalValueIndex: 27,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            weeklyDays.TypeMapping = SqliteStringTypeMapping.Default;
            weeklyDays.SetComparer(new ValueComparer<string>(
                bool (string c1, string c2) => c1 == c2,
                int (string c) => ((object)c).GetHashCode(),
                string (string c) => c));

            var weeksOffset = runtimeEntityType.AddProperty(
                "WeeksOffset",
                typeof(ushort),
                propertyInfo: typeof(ToDoEntity).GetProperty("WeeksOffset", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<WeeksOffset>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (ushort)0);
            weeksOffset.SetGetter(
                ushort (ToDoEntity instance) => ToDoEntityUnsafeAccessors.WeeksOffset(instance),
                bool (ToDoEntity instance) => ((object)ToDoEntityUnsafeAccessors.WeeksOffset(instance)).Equals(((object)(0))));
            weeksOffset.SetSetter(
                ToDoEntity (ToDoEntity instance, ushort value) =>
                {
                    ToDoEntityUnsafeAccessors.WeeksOffset(instance) = value;
                    return instance;
                });
            weeksOffset.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, ushort value) =>
                {
                    ToDoEntityUnsafeAccessors.WeeksOffset(instance) = value;
                    return instance;
                });
            weeksOffset.SetAccessors(
                ushort (IInternalEntry entry) => ToDoEntityUnsafeAccessors.WeeksOffset(((ToDoEntity)(entry.Entity))),
                ushort (IInternalEntry entry) => ToDoEntityUnsafeAccessors.WeeksOffset(((ToDoEntity)(entry.Entity))),
                ushort (IInternalEntry entry) => entry.ReadOriginalValue<ushort>(weeksOffset, 28),
                ushort (IInternalEntry entry) => entry.GetCurrentValue<ushort>(weeksOffset));
            weeksOffset.SetPropertyIndexes(
                index: 28,
                originalValueIndex: 28,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            weeksOffset.TypeMapping = UShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v),
                keyComparer: new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v),
                providerValueComparer: new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));
            weeksOffset.SetComparer(new ValueComparer<ushort>(
                bool (ushort c1, ushort c2) => ((object)c1).Equals(((object)(c2))),
                int (ushort c) => ((object)c).GetHashCode(),
                ushort (ushort c) => c));

            var yearsOffset = runtimeEntityType.AddProperty(
                "YearsOffset",
                typeof(ushort),
                propertyInfo: typeof(ToDoEntity).GetProperty("YearsOffset", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ToDoEntity).GetField("<YearsOffset>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (ushort)0);
            yearsOffset.SetGetter(
                ushort (ToDoEntity instance) => ToDoEntityUnsafeAccessors.YearsOffset(instance),
                bool (ToDoEntity instance) => ((object)ToDoEntityUnsafeAccessors.YearsOffset(instance)).Equals(((object)(0))));
            yearsOffset.SetSetter(
                ToDoEntity (ToDoEntity instance, ushort value) =>
                {
                    ToDoEntityUnsafeAccessors.YearsOffset(instance) = value;
                    return instance;
                });
            yearsOffset.SetMaterializationSetter(
                ToDoEntity (ToDoEntity instance, ushort value) =>
                {
                    ToDoEntityUnsafeAccessors.YearsOffset(instance) = value;
                    return instance;
                });
            yearsOffset.SetAccessors(
                ushort (IInternalEntry entry) => ToDoEntityUnsafeAccessors.YearsOffset(((ToDoEntity)(entry.Entity))),
                ushort (IInternalEntry entry) => ToDoEntityUnsafeAccessors.YearsOffset(((ToDoEntity)(entry.Entity))),
                ushort (IInternalEntry entry) => entry.ReadOriginalValue<ushort>(yearsOffset, 29),
                ushort (IInternalEntry entry) => entry.GetCurrentValue<ushort>(yearsOffset));
            yearsOffset.SetPropertyIndexes(
                index: 29,
                originalValueIndex: 29,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            yearsOffset.TypeMapping = UShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v),
                keyComparer: new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v),
                providerValueComparer: new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));
            yearsOffset.SetComparer(new ValueComparer<ushort>(
                bool (ushort c1, ushort c2) => ((object)c1).Equals(((object)(c2))),
                int (ushort c) => ((object)c).GetHashCode(),
                ushort (ushort c) => c));

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            var id = runtimeEntityType.FindProperty("Id");
            var annuallyDays = runtimeEntityType.FindProperty("AnnuallyDays");
            var childrenCompletionType = runtimeEntityType.FindProperty("ChildrenCompletionType");
            var color = runtimeEntityType.FindProperty("Color");
            var createdDateTime = runtimeEntityType.FindProperty("CreatedDateTime");
            var currentCircleOrderIndex = runtimeEntityType.FindProperty("CurrentCircleOrderIndex");
            var daysOffset = runtimeEntityType.FindProperty("DaysOffset");
            var description = runtimeEntityType.FindProperty("Description");
            var descriptionType = runtimeEntityType.FindProperty("DescriptionType");
            var dueDate = runtimeEntityType.FindProperty("DueDate");
            var icon = runtimeEntityType.FindProperty("Icon");
            var isBookmark = runtimeEntityType.FindProperty("IsBookmark");
            var isCompleted = runtimeEntityType.FindProperty("IsCompleted");
            var isFavorite = runtimeEntityType.FindProperty("IsFavorite");
            var isRequiredCompleteInDueDate = runtimeEntityType.FindProperty("IsRequiredCompleteInDueDate");
            var lastCompleted = runtimeEntityType.FindProperty("LastCompleted");
            var link = runtimeEntityType.FindProperty("Link");
            var monthlyDays = runtimeEntityType.FindProperty("MonthlyDays");
            var monthsOffset = runtimeEntityType.FindProperty("MonthsOffset");
            var name = runtimeEntityType.FindProperty("Name");
            var normalizeName = runtimeEntityType.FindProperty("NormalizeName");
            var orderIndex = runtimeEntityType.FindProperty("OrderIndex");
            var parentId = runtimeEntityType.FindProperty("ParentId");
            var referenceId = runtimeEntityType.FindProperty("ReferenceId");
            var remindDaysBefore = runtimeEntityType.FindProperty("RemindDaysBefore");
            var type = runtimeEntityType.FindProperty("Type");
            var typeOfPeriodicity = runtimeEntityType.FindProperty("TypeOfPeriodicity");
            var weeklyDays = runtimeEntityType.FindProperty("WeeklyDays");
            var weeksOffset = runtimeEntityType.FindProperty("WeeksOffset");
            var yearsOffset = runtimeEntityType.FindProperty("YearsOffset");
            var key = runtimeEntityType.FindKey(new[] { id });
            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<Guid>(key));
            key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<Guid>(key));
            runtimeEntityType.SetOriginalValuesFactory(
                ISnapshot (IInternalEntry source) =>
                {
                    var structuralType = ((ToDoEntity)(source.Entity));
                    return ((ISnapshot)(new Snapshot<Guid, string, ChildrenCompletionType, string, DateTimeOffset, uint, ushort, string, DescriptionType, DateOnly, string, bool, bool, bool, bool, DateTimeOffset?, string, string, ushort, string, string, uint, Guid?, Guid?, uint, ToDoType, TypeOfPeriodicity, string, ushort, ushort>(((ValueComparer<Guid>)(((IProperty)id).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid>(id)), (source.GetCurrentValue<string>(annuallyDays) == null ? null : ((ValueComparer<string>)(((IProperty)annuallyDays).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(annuallyDays))), ((ValueComparer<ChildrenCompletionType>)(((IProperty)childrenCompletionType).GetValueComparer())).Snapshot(source.GetCurrentValue<ChildrenCompletionType>(childrenCompletionType)), (source.GetCurrentValue<string>(color) == null ? null : ((ValueComparer<string>)(((IProperty)color).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(color))), ((ValueComparer<DateTimeOffset>)(((IProperty)createdDateTime).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTimeOffset>(createdDateTime)), ((ValueComparer<uint>)(((IProperty)currentCircleOrderIndex).GetValueComparer())).Snapshot(source.GetCurrentValue<uint>(currentCircleOrderIndex)), ((ValueComparer<ushort>)(((IProperty)daysOffset).GetValueComparer())).Snapshot(source.GetCurrentValue<ushort>(daysOffset)), (source.GetCurrentValue<string>(description) == null ? null : ((ValueComparer<string>)(((IProperty)description).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(description))), ((ValueComparer<DescriptionType>)(((IProperty)descriptionType).GetValueComparer())).Snapshot(source.GetCurrentValue<DescriptionType>(descriptionType)), ((ValueComparer<DateOnly>)(((IProperty)dueDate).GetValueComparer())).Snapshot(source.GetCurrentValue<DateOnly>(dueDate)), (source.GetCurrentValue<string>(icon) == null ? null : ((ValueComparer<string>)(((IProperty)icon).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(icon))), ((ValueComparer<bool>)(((IProperty)isBookmark).GetValueComparer())).Snapshot(source.GetCurrentValue<bool>(isBookmark)), ((ValueComparer<bool>)(((IProperty)isCompleted).GetValueComparer())).Snapshot(source.GetCurrentValue<bool>(isCompleted)), ((ValueComparer<bool>)(((IProperty)isFavorite).GetValueComparer())).Snapshot(source.GetCurrentValue<bool>(isFavorite)), ((ValueComparer<bool>)(((IProperty)isRequiredCompleteInDueDate).GetValueComparer())).Snapshot(source.GetCurrentValue<bool>(isRequiredCompleteInDueDate)), (source.GetCurrentValue<DateTimeOffset?>(lastCompleted) == null ? null : ((ValueComparer<DateTimeOffset?>)(((IProperty)lastCompleted).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTimeOffset?>(lastCompleted))), (source.GetCurrentValue<string>(link) == null ? null : ((ValueComparer<string>)(((IProperty)link).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(link))), (source.GetCurrentValue<string>(monthlyDays) == null ? null : ((ValueComparer<string>)(((IProperty)monthlyDays).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(monthlyDays))), ((ValueComparer<ushort>)(((IProperty)monthsOffset).GetValueComparer())).Snapshot(source.GetCurrentValue<ushort>(monthsOffset)), (source.GetCurrentValue<string>(name) == null ? null : ((ValueComparer<string>)(((IProperty)name).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(name))), (source.GetCurrentValue<string>(normalizeName) == null ? null : ((ValueComparer<string>)(((IProperty)normalizeName).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(normalizeName))), ((ValueComparer<uint>)(((IProperty)orderIndex).GetValueComparer())).Snapshot(source.GetCurrentValue<uint>(orderIndex)), (source.GetCurrentValue<Guid?>(parentId) == null ? null : ((ValueComparer<Guid?>)(((IProperty)parentId).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid?>(parentId))), (source.GetCurrentValue<Guid?>(referenceId) == null ? null : ((ValueComparer<Guid?>)(((IProperty)referenceId).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid?>(referenceId))), ((ValueComparer<uint>)(((IProperty)remindDaysBefore).GetValueComparer())).Snapshot(source.GetCurrentValue<uint>(remindDaysBefore)), ((ValueComparer<ToDoType>)(((IProperty)type).GetValueComparer())).Snapshot(source.GetCurrentValue<ToDoType>(type)), ((ValueComparer<TypeOfPeriodicity>)(((IProperty)typeOfPeriodicity).GetValueComparer())).Snapshot(source.GetCurrentValue<TypeOfPeriodicity>(typeOfPeriodicity)), (source.GetCurrentValue<string>(weeklyDays) == null ? null : ((ValueComparer<string>)(((IProperty)weeklyDays).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(weeklyDays))), ((ValueComparer<ushort>)(((IProperty)weeksOffset).GetValueComparer())).Snapshot(source.GetCurrentValue<ushort>(weeksOffset)), ((ValueComparer<ushort>)(((IProperty)yearsOffset).GetValueComparer())).Snapshot(source.GetCurrentValue<ushort>(yearsOffset)))));
                });
            runtimeEntityType.SetStoreGeneratedValuesFactory(
                ISnapshot () => Snapshot.Empty);
            runtimeEntityType.SetTemporaryValuesFactory(
                ISnapshot (IInternalEntry source) => Snapshot.Empty);
            runtimeEntityType.SetShadowValuesFactory(
                ISnapshot (IDictionary<string, object> source) => Snapshot.Empty);
            runtimeEntityType.SetEmptyShadowValuesFactory(
                ISnapshot () => Snapshot.Empty);
            runtimeEntityType.SetRelationshipSnapshotFactory(
                ISnapshot (IInternalEntry source) =>
                {
                    var structuralType = ((ToDoEntity)(source.Entity));
                    return ((ISnapshot)(new Snapshot<Guid>(((ValueComparer<Guid>)(((IProperty)id).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<Guid>(id)))));
                });
            runtimeEntityType.SetCounts(new PropertyCounts(
                propertyCount: 30,
                navigationCount: 0,
                complexPropertyCount: 0,
                complexCollectionCount: 0,
                originalValueCount: 30,
                shadowCount: 0,
                relationshipCount: 1,
                storeGeneratedCount: 0));
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "ToDos");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
